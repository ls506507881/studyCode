## 模块化的价值
疑问：写代码的时候，实现功能就好了，为什么要模块化？
### 最主要的目的：
- 解决命名冲突
对于一个复杂的网站/页面，可能js代码有上万行，在js的文件，全都是全局变量，如果不小心就容易重复声明。
- 依赖管理
对于一个项目，可能有很多js文件，jQ,自己写的组件等，这些js文件之间是相互依赖的。比如使用jQ,必须把jQ放到最前面。script标签有先后顺序。引入很多script标签后，再次添加新的script标签时，存放位置会产生疑虑。
### 其他价值
- 提高代码可读性
每个功能，一个模块，修改方便。
- 代码解耦，提高复用性
### 参考
[前端模块化开发的价值](https://github.com/seajs/seajs/issues/547)
### 必读文章
[模块化初探](http://book.jirengu.com/fe/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E6%A8%A1%E5%9D%97%E5%8C%96/%E6%A8%A1%E5%9D%97%E5%8C%96.html)
新建文件夹COMMONJS
a.js
```
var people = {
    name:'Herbert',
    printName: function(){
        console.log(this.name)
    }
}

module.exports = people;
// module.exports = 666;  把666导出去
//module.exports就是commonjs规范,代码执行在node下，天然支持这个
//作用：把当前的代码，导出去。
//module 模块; 组件; 
//exports 出口;输出
```
b.js
```
var p = require('./a');
// console.log(p)
//当需要其他文件模块的时候，只需要require+路径
//require需要; 要求; 想要; 命令;
//require 也是nodejs内部定义好的。
p.printName();
console.log('成功了')
//使用方法，命令行执行 node b.js

//require是同步获取数据，调用a,直接拿过来，而不是不去管他，等数据传过来在执行。
//因为服务端都是本地的文件。
//但如果把这一套放在浏览器端就有问题。
//1.路径问题  
//2.同步要把所有require请求都加载完成才执行，如果require数量很大，会加载慢。
```
common/AMD/CMD方法区别
```
//common写法
//调用一个模块，使用
var carousel = require('./carousel');
new carousel('.ct');

var tab = require('./tab')
tab.init()

var lazy = require('./lazy')
lazy.init('',function(){

})

//------------------
//AMD方法
require(['carousel','tab','lazy'],function(Carousel,Tab,Lazy){
    new Carousel();
    Tab.init();
    Lazy.init();
})


//-----------------
//CMD方法和common方法很类似。需要什么，就require什么
// 定义模块  myModule.js
define(function(require, exports, module) {
  var $ = require('jquery.js')
  $('div').addClass('active');
});

// 加载模块
seajs.use(['myModule.js'], function(my){

});
```

---------

## AMD&CMD&CommonJS

